#### 11. link 标签定义

<link> 标签定义文档与外部资源的关系。

<link> 标签最常见的用途是链接样式表。

> 注意： link 元素是空元素，它仅包含属性。

> 注意：此元素只能存在于 head 部分，不过它可出现任何次数。

#### 12. 页面导入样式时，使用 link 和 @import 有什么区别？

1. link是XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;

2. link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。

3. link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本(IE5及以下)的浏览器不支持。

4. link支持使用Javascript控制DOM去改变样式；而@import不支持。

#### 13. 你对浏览器的理解？

1. 浏览器的构成

   1）用户界面：包括地址栏，后退/前进按钮，书签目录等
   2）浏览器引擎：用来查询和操作渲染引擎的接口
   3）渲染引擎：用来显示请求的内容，eg.如果请求的内容为html，就负责解析html及 css,并将解析后的结果显示出来
   4）网络：用来完成网络调用，eg.http请求，有与平台无关的接口，可以在不同平台上工作
   5）UI后端
   6）Js解释器：用来解释执行js代码
   7）数据存储：属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，html5定义了 web database技术，一种轻量级完整的客户端存储技术

2. 浏览器内核的了解

   浏览器内核主要分成两部分：渲染引擎和js引擎
   最开始渲染引擎和js引擎没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只渲染引擎
   1）渲染引擎：负责取得网页的内容（HTML,XML,图像等等），整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核不同对于网页的语法解释会有不同，所以渲染的效果也不相同
   2）JS引擎：解析和执行javascript来实现网页的动态效果

3. 浏览器渲染过程

   简单地说，页面渲染就是浏览器将html代码根据CSS定义的规则显示在浏览器窗口中的这个过程。先来大致了解一下浏览器都是怎么工作的：

   1）用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；

   2）浏览器开始载入html代码，发现head标签内有一个link标签引用外部CSS文件；

   3）浏览器又发出CSS文件的请求，服务器返回这个CSS文件；

   4）浏览器继续载入html中body部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；

   5）浏览器在代码中发现一个img标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；

   6）服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码

   7）浏览器发现了一个包含一行Javascript代码的script标签，赶快运行它

   8）Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个div（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码

#### 14. 介绍一下你对浏览器内核的理解？

答：见上一问第二点

#### 15. 常见的浏览器内核比较

**1. Gecko内核**

​		以Mozilla浏览器为代表，FirefoxGecko是一套开放源代码的、以C++编写的网页排版引擎。Gecko是最流行的排版引擎之一。使用它的比较著名的浏览器是Firefox、Netscape6至9.

**2. Trident内核**

​		Trident又被称为MSHTML，是微软开发的一种排版引擎。使用Trident渲染引擎的浏览器主要有：IE、世界之窗浏览器、傲游、Avant、Sleipnir、GreenBrowser、NetCaptor和KKman等。

**3. Webkit内核**

​		代表浏览器有Safari、Chromewebkit。是一个开源项目，包含了来自KDE项目和苹果公司的一些组件，主要用于Mac OS系统，特点在于源码结构清晰、渲染速度极快。缺点是对网页代码的兼容性不高，导致一些编写不标准的网页无法正常显示。主要作品有Safari以及Chrome。

**4. Presto内核**

​		是由Opera Sofeware开发的浏览器排版引擎，Opera7.0及以上可使用。它取代了旧版Opera4到6使用的Elektra排版引擎，包括加入动态功能，而重新排版。

#### 16. 常见浏览器所用内核

1）IE浏览器内核：Trident内核，也是俗称的IE内核；

2）Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核；

3）Firefox浏览器内核：Gecko内核，俗称Firefox内核；

4）Safari浏览器内核：Webkit内核；

5）Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核;

6）360浏览器、猎豹浏览器内核：IE+Chrome双内核；

7）搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；

8）百度浏览器、世界之窗内核：IE内核；

9）2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核；

#### 17. 浏览器的渲染原理？

**渲染引擎简介**

　　本文所讨论的浏览器——Firefox、Chrome和Safari是基于两种渲染引擎构建的，Firefox使用Geoko——Mozilla自主研发的渲染引擎，Safari和Chrome都使用webkit。

 

**渲染主流程**

　　渲染引擎首先通过网络获得所请求文档的内容，通常以8K分块的方式完成。下面是渲染引擎在取得内容之后的基本流程：

　　解析html以构建dom树 -> 构建render树 -> 布局render树 -> 绘制render树

![img](https://pic002.cnblogs.com/images/2011/265173/2011110316263715.png)

 

 

 

　　这里先解释一下几个概念，方便大家理解：

　　DOM Tree：浏览器将HTML解析成树形的数据结构。

　　CSS Rule Tree：浏览器将CSS解析成树形的数据结构。

　　Render Tree: DOM和CSSOM合并后生成Render Tree。

　　layout: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。

　　painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。

　　reflow（回流）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。reflow 会从 <html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。

　　repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。

*注意：(1)display:none 的节点不会被加入Render Tree，而visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为display:none是更优的。*

　　  *(2)display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。*

　　　*(3)有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。*

 

　　来看看webkit的主要流程：*
*

![img](https://images2018.cnblogs.com/blog/1028513/201805/1028513-20180530154313816-1498972038.png)

 

　　再来看看Geoko的主要流程：

![img](https://images2018.cnblogs.com/blog/1028513/201805/1028513-20180530154341813-2090367224.jpg)

 


　　Gecko 里把格式化好的可视元素称做“帧树”（Frame tree）。每个元素就是一个帧（frame）。 webkit 则使用”渲染树”这个术语，渲染树由”渲染对象”组成。webkit 里使用”layout”表示元素的布局，Gecko则称为”reflow”。Webkit使用”Attachment”来连接DOM节点与可视化信息以构建渲染树。一个非语义上的小差别是Gecko在HTML与DOM树之间有一个附加的层 ，称作”content sink”，是创建DOM对象的工厂。

　　尽管Webkit与Gecko使用略微不同的术语，这个过程还是基本相同的，如下：

　　1. 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。

　　2. 将CSS解析成 CSS Rule Tree 。

　　3. 根据DOM树和CSSOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像Header或display:none的东西就没必要放在渲染树中了。

　　4. 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为layout，顾名思义就是计算出每个节点在屏幕中的位置。

　　5. 再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。

　　注意：*上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容*。



#### 18. 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）

**处理JS文件**

JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。

也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性（下文会介绍这两者的区别）。

JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。

> 原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构

这是为啥呢？

这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。前面我们介绍，不完整的CSSOM是无法使用的，但JavaScript中想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，**在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM**。

接下来我们对比下 defer 和 async 属性的区别：



![img](https://pic4.zhimg.com/80/v2-909c198b7ef020ad8529cfa97f4ffd6f_1440w.jpg)



其中蓝色线代表JavaScript加载；红色线代表JavaScript执行；绿色线代表 HTML 解析。

**1）情况1**

没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。

**2）情况2 （异步下载）**

async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。

**3）情况3 （延迟执行）**

defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。

defer 与相比普通 script，有两点区别：**载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。

在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载。

> 操作dom慢的原因

因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。

#### 19. async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）

defer和async是script标签的两个属性，用于在不阻塞页面文档解析的前提下，控制脚本的下载和执行。

在介绍他们之前，先了解一下页面的加载和渲染过程：

1. 浏览器通过HTTP协议请求服务器，获取HMTL文档并开始从上到下解析，构建DOM；
2. 在构建DOM过程中，如果遇到外联的样式声明和脚本声明，则暂停文档解析，创建新的网络连接，并开始下载样式文件和脚本文件；
3. 样式文件下载完成后，构建CSSDOM；脚本文件下载完成后，解释并执行，然后继续解析文档构建DOM
4. 完成文档解析后，将DOM和CSSDOM进行关联和映射，最后将视图渲染到浏览器窗口，在这个过程中，脚本文件的下载和执行是与文档解析同步进行，也就是说，它会阻塞文档的解析，如果控制得不好，在用户体验上就会造成一定程度的影响。
    所以我们需要清楚的了解和使用defer和async来控制外部脚本的执行。

**作用**

- defer：用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。
- async：新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。

**区别**

1）没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。

2）有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。

3）有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。

#### 20. 什么是文档的预解析？（浏览器解析过程）

JS代码的执行是由浏览器中的js解析器来执行的，js解析器执行js代码的时候，分为两个过程分为

预解析过程、代码执行过程。

1.预解析
直接看代码?

    console.log(a);// undefined
    var a = 10;
    
    function f() {
        console.log(b);
        var b = 20;
    }
       
    f();// undefined
正常理解，JS代码是顺序执行，console.log(a)输出变量a的时候，a变量并未声明，此时输出a应报错才对，同理f函数中输出变量b时b并未声明，也应该报错才对，但实际输出undefined并未报错。上面这段代码和下面这段代码等同：

    var a; 
    console.log(a);// undefined
    a = 10;
    
    function f() {
        var b; 
        console.log(b);
        b = 20;
    }
       
    f();// undefined
由此可见JS的预解析将变量的声明进行了提升。其实JS预解析也会将函数的定义进行提示。

    f1();// 未报错，输出f函数被调用
    function f1() {
        console.log("f函数被调用");
    }
和下面代码等同：

    function f1() {
        console.log("f函数被调用");
    }
    f1();// f函数被调用
2.预解析提升位置

    function f() {
            console.log(c);// undefined
            var c = 30;
        }
    console.log(c);// 报错
变量的提升只会在当前的作用域中提升，提前到当前作用域的最上面。函数中的变量只会提升到函数作用域中的的最前面。

函数表达式预解析提升问题:

    f();// 报错
    var f = function () {
        console.log("匿名函数被调用");
    };
    //和下面等同
    var f;
    f();// 报错
    f = function () {
        console.log("匿名函数被调用");
    };
此时会报错，f is not a function，这是因为函数表达式的写法其实是变量的赋值，不是一个函数的定义，预解析只会提升var f的声明，而 f = function(){…}；是变量的赋值不会提升，所以报错。

#### 21. HTML5 有哪些新特性、移除了那些元素？

**Html5新增了 27 个元素，废弃了 16 个元素，根据现有的标准规范，把 HTML5 的元素按优先级定义为**

**结构性属性、级块性元素、行内语义性元素和交互性元素 4 大类**  

**新增的元素**

**(1) 结构性元素主要负责web上下文结构的定义**

section：在 web 页面应用中，该元素也可以用于区域的章节描述。

header：页面主体上的头部， header 元素往往在一对 body 元素中。

footer：页面的底部（页脚），通常会标出网站的相关信息。

nav：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。

article：用于表现一篇文章的主体内容，一般为文字集中显示的区域。

**(2) 级块性元素主要完成web页面区域的划分，确保内容的有效分割。**

aside：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。

figure：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。

code：表示一段代码块。

dialog：用于表达人与人之间的对话，该元素包含 dt 和 dd 这两个组合元素， dt 用于表示说话者，而 dd 用来表示说话内容。

**(3) 行内语义性元素主要完成web页面具体内容的引用和描述，是丰富内容展示的基础。**

meter：表示特定范围内的数值，可用于工资、数量、百分比等。

time：表示时间值。

progress：用来表示进度条，可通过对其 max 、 min 、 step 等属性进行控制，完成对进度的表示和监事。

video：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。

audio：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。

**(4) 交互性元素主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。**

details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。

datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新。

menu：主要用于交互菜单（曾被废弃又被重新启用的元素）。

command：用来处理命令按钮。

**移除的元素**

- 纯表现的元素u、big、center、strike、tt、font、basefont
- 框架集frame、frameset、noframes

#### 22. 如何处理 HTML5 新标签的浏览器兼容问题？

1 处理HTML5新标签的浏览器兼容问题： 

当在页面中使用HTML5新标签时，可能会得到三种不同的结果：

1）新标签被当作错误处理并被忽略，在DOM构建时会当作这个标签不存在。

2）新标签被当作错误处理，并在DOM构建时，这个新标签会被构造成行内元素。

3）新标签被识别为HTML5标签，然后用DOM节点对其进行替换。

2 不能识别HTML5新标签而不能使用，解决办法有两种：

1）实现标签被识别

通过document.createElement（tagName）方法即可让浏览器识别新标签，浏览器支持新标签后，还可以为新标签添加CSS样式。

2）JavaScript解决方案

a）使用html5shim：

在<head>中调用以下代码：


<!--[if lt IE 9]>
	<script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script>
<![endif]-->
当然也可以直接把这个文件下载到自己的网站上，但这个文件必须在head标签中调用。

b）使用kill IE6

在</body>之前调用以下代码：


<!--if lte IE 6]>
	<script src="http://letskillie6.googlecode.com/svn/trunk/letskillie6.zh_CN.pack.js"></script> 
<![endif]-->

#### 23. 简述一下你对 HTML 语义化的理解？

1）HTML 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;

2）即使在没有样式 CSS 的情况下也能以一种文档格式显示，并且是容易阅读的;

3）搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，有利于 SEO;

4）使阅读源代码的人更容易将网站分块，便于阅读、维护和理解。

#### 24. iframe 有那些缺点？

 **iframe的优点：**

1）iframe能够原封不动的把嵌入的网页展现出来。

2）如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。

3）网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。

4）如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。

**iframe的缺点：**

1）会产生很多页面，不容易管理。

2）iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。

3）代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。

4）很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。

5）iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。 分析了这么多，现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。

#### 25. title 与 h1 的区别？

**联系：**

​		从网站角度看，title更重于网站信息。title可以直接告诉搜索引擎和用户这个网站是关于什么主题和内容的。

​		从文章角度看，h1则是用于概括文章主题。用户进入内容页，想看到的当然就是文章的内容，h1文章标题就是最重要的。

​		文章标题最好只有一个，多个h1会导致搜索引擎不知道这个页面哪个标题内容最重要，导致淡化这个页面的标题和关键词，起不到突出主题的效果。

**区别：**

​		h1突出文章主题，面对用户，更突出其视觉效果，突出网站标题或关键字用title。一篇文章，一个页面最好只用一个h1，多个h1会稀释主题。

​		一个网站可以有多个title,最好一个单页用一个title，以便突出网站页面主体信息，从seo看，title权重比h1高，适用性比h1广。

​		标记了h1的文字页面给予的权重会比页面内其他权重高很多。一个好的网站是h1和title并存，既突出h1文章主题，又突出网站主题和关键字。达到双重优化网站的效果。

