#### 61. style 标签写在 body 后与 body 前有什么区别？

```
页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题）
```

#### 62. 什么是 CSS 预处理器 / 后处理器？

```
CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件。

预处理器例如：LESS、Sass、Stylus，用来预编译Sass或lesscsssprite，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。

CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后
处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。

后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。
```

#### 64. 使用 rem 布局的优缺点？

```
优点：
在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好。

缺点：
1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。
2）使用iframe引用也会出现问题。
3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。
```

#### 65. 几种常见的 CSS 布局

+ ##### 单列布局

  + 常见的单列布局有两种：
    + header,content和footer等宽的单列布局
    + header与footer等宽,content略窄的单列布局

+ ##### 两列自适应布局

  两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式

  + ###### float + overflow: hidden

    ```
    如果是普通的两列布局，浮动+普通元素的margin便可以实现。
    但如果是自适应的两列布局，利用float+overflow:hidden便可以实现，这种办法主要通过overflow触发BFC,而BFC不会重叠浮动元素。由于设置overflow:hidden并不会触发IE6-浏览器的haslayout属性，所以需要设置zoom:1来兼容IE6-浏览器。具体代码如下：
    
    <div class="parent" style="background-color: lightgrey;">
        <div class="left" style="background-color: lightblue;">
            <p>left</p>
        </div>
        <div class="right"  style="background-color: lightgreen;">
            <p>right</p>
            <p>right</p>
        </div>        
    </div>
    
    .parent {
      overflow: hidden;
      zoom: 1;
    }
    .left {
      float: left;
      margin-right: 20px;
    }
    .right {
      overflow: hidden;
      zoom: 1;
    }
    ```

  + ###### flex布局

    ```
    Flex布局，也叫弹性盒子布局，区区简单几行代码就可以实现各种页面的的布局。
    
    //html部分同上
    .parent {
      display:flex;
    }  
    .right {
      margin-left:20px; 
      flex:1;
    }
    ```

  + ###### grid布局

    ```
    Grid布局，是一个基于网格的二维布局系统，目的是用来优化用户界面设计。
    
    //html部分同上
    .parent {
      display:grid;
      grid-template-columns:auto 1fr;
      grid-gap:20px
    } 
    ```

+ ##### 三栏布局

  特征：中间列自适应宽度，旁边两侧固定宽度

  + ###### 圣杯布局

    ```
    比较特殊的三栏布局，同样也是两边固定宽度，中间自适应，唯一区别是dom结构必须是先写中间列部分，这样实现中间列可以优先加载。
    ```

  + ###### 双飞翼布局

    ```
    同样也是三栏布局，在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题。
    ```

  + ###### 两种布局实现方式对比:

    + 两种布局方式都是把主列放在文档流最前面，使主列优先加载。
    + 两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局。
    + 两种布局方式的不同之处在于如何处理中间主列的位置：
      + 圣杯布局是利用父容器的左、右内边距+两个从列相对定位；
      +  双飞翼布局是把主列嵌套在一个新的父级块中利用主列的左、右外边距进行布局调整

+ ##### 等高布局

  等高布局是指子元素在父元素中高度相等的布局方式。接下来我们介绍常见几种实现方式：

  + ###### 利用正padding+负margin

    ```
    我们通过等布局便可解决圣杯布局的第二点缺点，因为背景是在 padding 区域显示的，设置一个大数值的 padding-bottom，再设置相同数值的负的 margin-bottom，并在所有列外面加上一个容器，并设置 overflow:hidden 把溢出背景切掉。这种可能实现多列等高布局，并且也能实现列与列之间分隔线效果，结构简单，兼容所有浏览器。
    ```

  + ###### 利用背景图片

    ```
    这种方法是我们实现等高列最早使用的一种方法，就是使用背景图片，在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假象。实现方法简单，兼容性强，不需要太多的css样式就可以轻松实现,但此方法不适合流体布局等高列的布局。
    ```

  + ###### 模仿表格布局

    ```
    这是一种非常简单，易于实现的方法。不过兼容性不好，在ie6-7无法正常运行。
    
       <div class="container table">
          <div class="containerInner tableRow">
            <div class="column tableCell cell1">
              <div class="left aside">
                ....
              </div>
            </div>
            <div class="column tableCell cell2">
              <div class="content section">
                ...
              </div>
            </div>
            <div class="column tableCell cell3">
              <div class="right aside">
                ...
              </div>
            </div>
          </div>
        </div>
        
    .table {
      width: auto;
      min-width: 1000px;
      margin: 0 auto;
      padding: 0;
      display: table;
    }
    .tableRow {
      display: table-row;
    }
    .tableCell {
      display: table-cell;
      width: 33%;
    }
    .cell1 {
      background: #f00;
      height: 800px;
    }
    .cell2 {
      background: #0f0;
    }
    .cell3 {
      background: #00f;
    }
    ```

  + ###### 使用边框和定位

    ```
    这种方法是使用边框和绝对定位来实现一个假的高度相等列的效果。结构简单，兼容各浏览器，容易掌握。假设你需要实现一个两列等高布局，侧栏高度要和主内容高度相等。
    
    #wrapper {
      width: 960px;
      margin: 0 auto;
    }
    #mainContent {
      border-right: 220px solid #dfdfdf;
      position: absolute;
      width: 740px;
      height: 800px;  
      background: green;
    }
    #sidebar {
      background: #dfdfdf;
      margin-left: 740px;
      position: absolute;
      height: 800px;
      width: 220px;
    }
    
    <div id="wrapper">
        <div id="mainContent">...</div>
        <div id="sidebar">...</div>
    </div>
    ```

+ ##### 粘连布局

  ```
  特点：
  
  1）有一块内容<main>，当<main>的高康足够长的时候，紧跟在<main>后面的元素<footer>会跟在<main>元素的后面。
  
  2）当<main>元素比较短的时候(比如小于屏幕的高度),我们期望这个<footer>元素能够“粘连”在屏幕的底部
  
  具体代码如下：
  
      <div id="wrap">
        <div class="main">
          main <br />
          main <br />
          main <br />
        </div>
      </div>
      <div id="footer">footer</div>
  
     * {
          margin: 0;
          padding: 0;
        }
        html,
        body {
          height: 100%;//高度一层层继承下来
        }
        #wrap {
          min-height: 100%;
          background: pink;
          text-align: center;
          overflow: hidden;
        }
        #wrap .main {
          padding-bottom: 50px;
        }
        #footer {
          height: 50px;
          line-height: 50px;
          background: deeppink;
          text-align: center;
          margin-top: -50px;
        }
  ```

  ```
  实现步骤:
  
  1) footer必须是一个独立的结构，与wrap没有任何嵌套关系
  
  2) wrap区域的高度通过设置min-height，变为视口高度
  
  3) footer要使用margin为负来确定自己的位置
  
  4) 在main区域需要设置 padding-bottom。这也是为了防止负 margin 导致 footer 覆盖任何实际内容。
  ```

#### 67. transition 和 animation 的区别

```
transition关注的是CSSproperty的变化，property值和时间的关系是一个三次贝塞尔曲线。

animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。
```

