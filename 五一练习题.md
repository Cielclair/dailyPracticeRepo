#### 16. CSS 多列等高如何实现？

##### 1）真实等高布局 flex

**技术点：弹性盒子布局flex，默认值就是自带等高布局的特点。**

定义flex布局的时候，有一些默认值。

`flex-direction` 属性定义主轴的方向。默认值为`row`，一般是水平显示。flex容器的主轴被定义为与文本方向相同。 主轴起点和主轴终点与内容方向相同。

`align-item`属性定义flex子项在flex容器的当前行的侧轴（纵轴 或者说 交叉轴）方向上的对齐方式。默认值为 `stretch`，元素被拉伸以适应容器

##### 2）真实等高布局 table-cell

**技术点：table布局天然就具有等高的特性。**

display设置为`table-cell`，则此元素会作为一个表格单元格显示。类似于使用标签&lt;td&gt;或者&lt;th&gt;

##### 3）假等高列布局 内外边距底部正负值

**实现：设置父容器的overflow属性为hidden。给每列设置比较大的底内边距，然后用数值相似的负外边距消除这个高度。**

- 不考虑可扩展性，只需要将padding-bottom/margin-bottom ，设置为最高列与最低列相差高度值，就可以得到等高效果。
- 考虑扩展性，为了防止将来可能某列高度大量的增加或减少，所有，我们设置了一个比较大的值。

**技术点**

+ background 会填充内边距 padding，而不会填充外边距 margin 。margin具有坍塌性，可以设置负值。

+ float:left。使用float，元素会脱离文档流，使其浮动至最近的文档流元素。

+ overflow:hidden; 设置overflow属性为hidden，这样会让父容器产生BFC（Block Fromatting Context块级格式化上下文）效果，消除float带来的影响。同时，根据需要，会截取内容以适应填充框，将超出容器的部分隐藏。

#### 17.  经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧 ？

##### 1）背景介绍

​		所谓的浏览器兼容性问题，是指因为不同的浏览器对同一段代码有不同的解析，造成页面显示效果不统一的情况。在大多数情况下，我们的需求是，无论用户用什么浏览器来查看我们的网站或者登陆我们的系统，都应该是统一的显示效果。所以浏览器的兼容性问题是我们web前端开发人员经常会碰到和必须要解决的问题.

##### 2）解决浏览器兼容的主要方法是css hack 那么到底什么是css hack呢？

由于不同厂商的流览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack!

##### 3）常见问题

+ 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。

+ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.

+ IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。

  ```
  浮动ie产生的双倍距离 
  
  #box{ float:left; width:10px; margin:0 0 0 100px;}
  
  这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——*display:inline;将其转化为行内属性。(*这个符号只有ie6会识别)
  
  渐进识别的方式，从总体中逐渐排除局部。
  
  首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。
  接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。
  
  css
  
   .bb{
   	background-color:#f1ee18;/*所有识别*/
   	.background-color:#00deff\9; /*IE6、7、8识别*/
   	+background-color:#a200ff;/*IE6、7识别*/
   	_background-color:#1e0bd1;/*IE6识别*/
   }
  ```

+ IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;
   Firefox下,只能使用getAttribute()获取自定义属性。

  解决方法：统一通过getAttribute()获取自定义属性。

+ IE下,even对象有x,y属性,但是没有pageX,pageY属性; Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。

+ 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。

+ Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。

+ 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:
   L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}

##### 4)解决方案

CSS Hack大致有3种表现形式，CSS属性前缀法、选择器前缀法以及IE条件注释法（即HTML头部引用if IE）Hack，实际项目中CSS Hack大部分是针对IE浏览器不同版本之间的表现差异而引入的。

属性前缀法(即类内部Hack)：例如 IE6能识别下划线"_"和星号" * "，IE7能识别星号" * "，但不能识别下划线"_"，IE6~IE10都认识"\9"，但firefox前述三个都不能认识。

选择器前缀法(即选择器Hack)：例如 IE6能识别*html .class{}，IE7能识别*+html .class{}或者*:first-child+html .class{}。

IE条件注释法(即HTML条件注释Hack)：针对所有IE(注：IE10+已经不再支持条件注释)： IE浏览器显示的内容 ，针对IE6及以下版本： 只在IE6-显示的内容 。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。

background-color:orange;/* all - for Firefox/Chrome */

background-color:red\0;/* ie 8*/

background-color:blue\9\0;/* ie 9/10 */

*background-color:black;/* ie 6/ ie 7 */

_background-color:green;/* ie 6  */

#### 18.  li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？

浏览器的默认行为是把inline元素间的空白字符（空格换行tab）渲染成一个空格，也就是我们上面的代码换行后会产生换行字符，而它会变成一个空格，当然空格就占用一个字符的宽度。

##### 解决方案：

**方法一：** 既然是因为< li>换行导致的，那就可以将< li>代码全部写在一排，如下

```
<div class="wrap">
<h3>li标签空白测试</h3>
<ul>
<li class="part1"></li><li class="part2"></li><li class="part3"></li><li class="part4"></li>
</ul>
</div>
```

**方法二：** 我们为了代码美观以及方便修改，很多时候我们不可能将< li>全部写在一排，那怎么办？既然是空格占一个字符的宽度，那我们索性就将内的字符尺寸直接设为0，将下面样式放入样式表，问题解决。

```
.wrap ul{font-size:0px;}
```

但随着而来的就是中的其他文字就不见了，因为其尺寸被设为0px了，我们只好将他们重新设定字符尺寸。

**方法三：** 本来以为方法二能够完全解决问题，但经测试，将li父级标签字符设置为0在Safari浏览器依然出现间隔空白；既然设置字符大小为0不行，那咱就将间隔消除了，将下面代码替换方法二的代码，目前测试完美解决。同样随来而来的问题是li内的字符间隔也被设置了，我们需要将li内的字符间隔设为默认。

```
.wrap ul{letter-spacing: -5px;}
```

之后记得设置li内字符间隔

```
.wrap ul li{letter-spacing: normal;}
```

#### 21. CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？

##### 1）visibility的第三种值collapse：

对于一般的元素，它的表现跟display:hidden是一样的。
但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟display: none一样，也就是说，它们占用的空间也会释放。

##### 2）在不同浏览器下的区别：

在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。
在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。

#### 22. width: auto 和 width: 100% 的区别

##### **1）width: auto**

+ 块级元素默认的宽度值，意味着浏览器会自己选择一个合适的宽度值。
+ 内容的宽度='margin-left' + 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width' + 'margin-right'
+ 如果margin-left' + 'border-left-width' + 'padding-left' + 'padding-right' + 'border-right-width' + 'margin-right'比较大，就减小width的值，如果比较小呢，就增大width的值，使其满足上面的表达式。

##### 2）width: 100%;

当width设置为100%之后，它的宽度就是父级的width，并且随着父级的width自动变化，增加子元素的padding和margin之后，它的width还是不变的，这是与设置为auto的区别。

##### 3）**width: auto和width: 100%的区别**

+ width: 100% 并不包含margin-left margin-right的属性值，直接取其父容器的宽度加上含margin-left /margin-right的值。如果设置了margin那新的width值是容器的宽度加上margin的值。就会发现加了 margin相对应的边就会多出设置的空白。而且会多出横向滚动条因为宽度已经超出了屏幕的范围，(这条相对于父容器是body)。
+ width: auto包含margin-left/margin-right的属性值。width: auto总是占据整行，这其中margin的值已经包含其中了，如果要设置margin的值那就用一整行然后减去margin的值就得到了现在的宽度了。减去的这个值就是相应边得空白。显著的特征是这个没有横向滚动条出现也就是宽度没有增加。
+ 一般width: auto使用的多，因为这样灵活，而width: 100%使用比较少，因为在增加padding或者margin的时候，容易使其突破父级框，破环布局。

#### 23. 绝对定位元素与非绝对定位元素的百分比计算的区别

+ 绝对定位的宽高百分比计算是相对于padding box的，也就是说会把padding的值计算在内，但是，非绝对定位元素则是相对于content box计算的。

#### 24. 简单介绍使用图片 base64 编码的优点和缺点。

图片的 base64 编码就是可以将一副图片数据编码成一串字符串，使用该字符串代替图像地址。

##### 优势：

- 减少http请求
- 模块封装

##### 弊端

- base64编码的长度有些长（base64一般会比原图要大一些）
- 获取修改比较麻烦

##### 使用场景

- 图片很少或不会更新
- 图片实际尺寸很小
- 图片在网站多次使用

#### 25. 'display'、'position' 和 'float' 的相互关系？

+ 如果'display'设置为'none'，用户端必须忽略掉'position'和'float'。在这种情况下，元素不产生框。
+ 否则，'position'设置为'absolute'或'fixed'，'display'设置为'block'且'float'设置为'none'。框的位置将由'top'，'right'，'bottom'和'left'属性和该框的包含块确定。
+ 否则，如果'float'的值不是'none'，'display'设置为'block'并且该框浮动。
+ 否则，应用指定的其它'display'属性。
  + 即如果'position'设置为'absolute'或'fixed'且‘float’的值不为‘none’，display的值就会被设置为‘block’，所以设置display: inline; float: left;等同于float:left，display:inline 的属性并未生效。因为用户端会忽略掉对’display‘的设置。float:left和display:inline-block当然是不等同的。
+ **position:absolute和float会隐式的改变display类型，**
  不论之前是什么类型的元素（display:none除外），只要设置了position:absolute或float，都会让元素以display:inline-block的方式显示，可以设置长宽，默认宽度并不占满父元素，就算是显示的设置display:inline或display:block，仍然无效。
  float在IE6下的双倍边距bug就是利用添加display:inline来解决的
  注意一点的是，position:relative并不能够隐式的改变display的类型

#### 26. margin 重叠问题的理解。

+ 两个普通元素上下的margin会合并为一个margin，哪个大选哪个！

+  两个浮动元素不会出现margin传递的问题，依然是上面元素的margin-bottom和下面元素的margin-top相加作为两者之间的margin值。
  + 当父元素不加边框，不设置宽高，即父级没有触发haslayout时
    + IE6、7和标准浏览器下，均会发生margin传递问题
    + 子元素和父元素的高度相同（子元素的top将和父元素的top在一条直线上，bottom将和父元素的bottom在一条直线上）
    + 而父元素则选择两者之间大的数值作为父元素的margin-top值和margin-bottom值！！！
    + 子元素的margin-left和margin-right值依然存在
  + 当父元素不加边框，但是，设置宽或高或zoom：1；即父级加可以触发haslayout的属性时
    + 标准浏览器下，会发生margin传递
    + 但是在IE6、7下则不会发生margin传递（即子元素的margin就是相对于父元素的，不会传递给父级）
  + 当父级加边框，并且父级没有触发haslayout时
    + 标准浏览器下，不会发生margin传递
    + IE6、7下，子元素的margin彻底消失！
  + 当父级加边框，并且父级触发haslayout（即加width或height或zoom：1）时，
    + IE6、7和标准浏览器下，都不会发生margin传递！！！
+ 两个Div（A、B）上下之间没有margin值，但是A中有子元素有margin，这时该子元素的margin值会传递到两者间，会使A、B两个元素之间填充上margin，仅限垂直方向
+ 解决外边距重叠方案
  + 外层元素padding代替
  + 外层元素 overflow:hidden;
  + 内层元素绝对定位 postion:absolute:
  + 内层元素 加float:left;或display:inline-block;
  + 内层元素padding:1px;
  + 内层元素透明边框 border:1px solid transparent;

#### 27. 对 BFC 规范（块级格式化上下文：block formatting context）的理解？

##### **BFC 是什么？**

​		BFC 就是“块级格式化上下文”的意思,创建了 BFC 的元素就是一个独立的盒子,不过只有 Block-level box 可以参与创建 BFC, 它规定了内部的 Block-level Box 如何布局,并且与这个独立盒子里的布局不受外部影响,当然它也不会影响到外面的元素。

##### **BFC 有一下特性：**

+ 内部的 Box 会在垂直方向,从顶部开始一个接一个地放置。
+ Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生叠加,每个元素的margin box 的左边, 与包含块 border box 的左边相接触(对于从左往右的格式化,否则相反)。即使存在浮动也是如此。
+ BFC 的区域不会与 float box 叠加。
+ BFC 就是页面上的一个隔离的独立容器,容器里面的子元素不会影响到外面的元素,反之亦然。
+ 计算 BFC 的高度时,浮动元素也参与计算。

##### **如何触发 BFC？**

+ float 除了 none 以外的值
+ overflow 除了 visible 以外的值(hidden,auto,scroll)
+ display (table-cell,table-caption,inline-block, flex, inline-flex)
+ position 值为(absolute,fixed)
+ fieldset 元素
+ (W3C CSS 2.1 规范中的一个概念,它是一个独立容器,决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。)一个页面是由很多个 Box 组成的,元素的类型display 属性,决定了这个 Box 的类型。
+ 不同类型的 Box,会参与不同的 Formatting Context(决定如何渲染文档的容器),因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。

#### 28. IFC 是什么？

+ IFC(Inline formatting contexts)，即行内格式化上上下文。
  + 一个内联盒是一个(特殊的)内联级盒，其内容参与了它的包含内联格式化上下文。一个'display'值为'inline'的不可替换元素会生成一个内联盒。不属于内联盒的内联块级盒（例如，可替换内联级元素，inline-block元素和inline-table元素）被称为原子内联级盒（atomic inline-level boxes），因为它们作为单一的不透明盒（opaque box）参与其内联格式化上下文。

+ 通常是display:inline的元素，当然也包括inline-block和inline-table，这些元素生成行内级元素，他们会在水平方向一个接一个排列，如果宽度不够排列将生成多行。而这些盒子中只有inline是行内盒，并参与生成行内格式化上下文，其他不参与上下文的行内级元素被称为原子行内级盒。即：
  - 行内盒：与其内容参与行内格式化上下文，元素有display:inline的不可替换元素。
  - 原子行内级盒：以单一的不透明盒的形式参与行内格式化上下文，元素有display:inline的替换元素、inline-block和inline-table元素。

#### 29. 请解释一下为什么需要清除浮动？清除浮动的方式

##### 1）为什么要清除浮动？

当元素有浮动属性时，高度会坍塌，高度的坍塌会对其父元素或后面的元素产生影响，出现布局错乱的现象，可以通过清除浮动的方法来解决。

##### 2）浮动的影响是怎么产生的？

浮动是将块元素独占一行的属性取消，允许其它元素与它在同一行，其核心就是使这个块从原来的文档流模式中分离出来，它后面的对象就视它不存在，浮动元素的高度不能撑起父元素的高度，也就出现了高度坍塌。

##### 清除浮动的方式

1、给父级div定义高度height
2、父级div设置overflow: hidden;
3、利用伪对象after方法，作用于浮动元素的父级

```
.clearFix:after{
    clear:both;
    display:block;
    height:0;
    content:"";
}
.clearFix{zoom:1;}
```

zoom: 1的原理：当设置了zoom的值之后，所设置的元素就会扩大或缩小，高度宽度就会重新计算，这里一旦改变zoom值是其实也会发生重新渲染。
4、底部加一个空的div

```
<div class="clear"></div>
.clear{clear:both;}
```

#### 30. 使用 clear 属性清除浮动的原理？

+ clear 属性定义了元素的哪边上不允许出现浮动元素。在 CSS1 和 CSS2 中，这是通过自动为清除元素（即设置了 clear属性的元素）增加上外边距实现的。
+ 在 CSS2.1中，会在元素上外边距之上增加清除空间，而外边距本身并不改变。不论哪一种改变，最终结果都一样，如果声明为左边或右边清除，会使元素的上外边框边界刚好在该边上浮动元素的下外边距边界之下。

#### 31. zoom:1 的清除浮动原理?

当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染

#### 32. 移动端的布局用过媒体查询吗？

```
 媒体查询 + rem单位布局 = 移动端布局
 
 @media all and (max-width: 320px){
        html{
            font-size: 12px;
        }
    }
    @media all and (min-width: 321px) and (max-width: 375px){
        html{
            font-size: 14px;
        }
    }
    @media all and (min-width:376px){
        html{
            font-size: 16px;
        }
    }
```

#### 33. 使用 CSS 预处理器吗？喜欢哪个？

  SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS)

#### 34. CSS 优化、提高性能的方法有哪些？

+ 首推的是合并css文件，如果页面加载10个css文件，每个文件1k，那么也要比只加载一个100k的css文件慢。
+ 减少css嵌套，最好不要套三层以上。
+ 不要在ID选择器前面进行嵌套，ID本来就是唯一的而且人家权值那么大，嵌套完全是浪费性能。
+ 建立公共样式类，把相同样式提取出来作为公共类使用，比如我们常用的清除浮动等。
+ 减少通配符*或者类似[hidden="true"]这类选择器的使用，挨个查找所有...这性能能好吗？当然重置样式这些必须 的东西是不能少的。
+ 巧妙运用css的继承机制，如果父节点定义了，子节点就无需定义。
+ 拆分出公共css文件，对于比较大的项目我们可以将大部分页面的公共结构的样式提取出来放到单独css文件里， 这样一次下载后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定。
+ 不用css表达式，表达式只是让你的代码显得更加炫酷，但是他对性能的浪费可能是超乎你的想象的。
+ 少用css rest，可能你会觉得重置样式是规范，但是其实其中有很多的操作是不必要不友好的，有需求有兴趣的 朋友可以选择normolize.css
+ cssSprite，合成所有icon图片，用宽高加上bacgroud-position的背景图方式显现出我们要的icon图，这是一种 十分实用的技巧，极大减少了http请求。
+ 当然我们还需要一些善后工作，CSS压缩(这里提供一个在线压缩 YUI Compressor ，当然你会用其他工具来压缩是十 分好的)，
+ GZIP压缩，Gzip是一种流行的文件压缩算法，详细做法可以谷歌或者百度。

#### 35. 浏览器是怎样解析 CSS 选择器的？

+ CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。
+ 而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。

#### 