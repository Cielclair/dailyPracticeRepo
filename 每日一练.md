[诚意满满的前端面试总结](https://juejin.im/post/5e5dc46ce51d4526ce614cc1#heading-2)

### 4/16

#### 1. DOCTYPE 的作用是什么？
> `DOCTYPE`是document type(文档类型)的简写,用来告诉浏览器的解析器使用哪种`HTML`或`XHTML`规范解析页面。

#### 2. 标准模式与兼容模式各有什么区别？
> Standards（标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而Quirks（兼容）模式（也就是松散呈现模式或者怪异模式）用于呈现为传统浏览器而设计的网页。

#### 3. HTML5 为什么只需要写`<!DOCTYPE HTML>`，而不需要引入 DTD？
> HTML 4.01 基于 SGML，需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。
> HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为。

#### 4. SGML 、HTML 、XML和XHTML的区别？
> SGML是标准通用标记语言,简单的说，就是比HTML，XML更老的标准，这两者都是由SGML发展而来的。
> `XHTML(eXtensible HyperText Markup Language)`，是一种标记语言，表现方式与超文本标记语言（HTML）类似，不过语法上更加严格。从继承关系上讲，HTML是一种基于标准通用标记语言（SGML）的应用，是一种非常灵活的置标语言，而XHTML则基于可扩展标记语言（xml），XML是SGML的一个子集。

----

### 4/17

#### 6. 行内元素定义
> 一个行内元素只占据它对应标签的边框所包含的空间。

#### 7. 块级元素定义
> 块级元素占据其父元素（容器）的整个空间，因此创建了一个“块”。

#### 8. 行内元素与块级元素的区别？
> 块级元素明显的特征是占用页面的一整行，和它同级的下一个元素只能在它的下面另起一行。
> 行内元素相对于块级元素，不占用一整行的空间，可以在一行内进行排列。行内元素的宽高设定是不占据空间的，它本身决定自身的宽高，对其设置padding和margin没有垂直方向的效果，但是在水平方向是具有效果的。

#### 9. HTML5 元素的分类
> HTML5新增了27个元素，废弃了16个元素，根据现有的标准规范，把HTML5的元素按优先级定义为结构性属性、级块性元素、行内语义性元素和交互性元素4大类。

#### 10. 空元素定义
> 一个空元素（empty element）可能是 HTML，SVG，或者 MathML 里的一个不可能存在子节点（例如内嵌的元素或者元素内的文本）的element。
> HTML，SVG 和 MathML 的规范都详细定义了每个元素能包含的具体内容（define very precisely what each element can contain）。许多组合是没有任何语义含义的，比如一个 `<audio>` 元素嵌套在一个 `<hr>` 元素里。
> 在 HTML 中，通常在一个空元素上使用一个闭标签是无效的。例如， `<input type="text"></input>` 的闭标签是无效的 HTML。

----

### 4/20

#### 11. link 标签定义

> link标签是用于连接与该页面相关的其他页面的标签，但是，此标签与网站的外观无直接关系。
>
> 所以基本上它是在head标签中写的。
>
> link标签通常用于读取作为外部文件的CSS和JavaScript，以及读取名为favicon的web图标。

#### 12. 页面导入样式时，使用 link 和 @import 有什么区别？

> 1. `link`属于*XHTML*标签，而`@import`完全是*CSS*提供的一种方式。link标签除了可以加载CSS外，还可以做很多其它的事情，比如定义RSS，定义rel连接属性等，@import就只能加载CSS了。
> 2. 加载顺序的差别。当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS 会等到页面全部被下载完再被加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁），网速慢的时候很明显。
> 3. 兼容性的差别。由于@import是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题。
> 4. 使用dom控制样式时的差别。当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。

#### 13. 你对浏览器的理解？

> 浏览网页
>
> 网页端调试
>
> 客户端渲染

#### 14. 介绍一下你对浏览器内核的理解？

> 解析的过程
>
> 脚本类语言
>
> > 需要后端的东西解析
>
> 编译类封装

> 主要分成两部分：**渲染引擎(Layout Engine或 Rendering Engine)** 和** JS 引擎**。
>
> - **渲染引擎**：负责取得网页的内容（HTML、 XML 、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。
>
> - **JS引擎则**：解析和执行 javascript 来实现网页的动态效果。
>
> 最开始渲染引擎和JS引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。

#### 15. 常见的浏览器内核比较

> 1. Trident：
>
> 该内核程序在1997年的IE4中首次被采用，是微软在Mosaic代码的基础之上修改而来的，并沿用到IE11，也被普遍称作”IE内核”。Trident实际上是一款开放的内核，其接口内核设计的相当成熟，因此才有许多采用IE内核而非IE的浏览器涌现。
>  Trident内核的常见浏览器有IE、360安全浏览器、猎豹安全浏览器、傲游浏览器、百度浏览器、世界之窗浏览器、2345浏览器、腾讯TT、搜狗高速浏览器、UC浏览器等。
>
> 2. Gecko：
>
> Gecko(Firefox内核)，Netscape6开始采用的内核，后来的Mozilla FireFox（火狐浏览器）也采用了该内核，Gecko的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko内核的浏览器也很多，此外Gecko也是一个跨平台内核，可以在Windows、 BSD、Linux和Mac OS X中使用。
>  Gecko内核常见的浏览器： Mozilla Firefox、Mozilla SeaMonkey、waterfox（Firefox的64位开源版）、Iceweasel。
>
> 3. Presto：
>
> Presto(Opera前内核) (已废弃)， Opera12.17及更早版本曾经采用的内核，现已停止开发并废弃，该内核在2003年的Opera7中首次被使用，该款引擎的特点就是渲染速度的优化达到了极致，然而代价是牺牲了网页的兼容性。实际上这是一个动态内核，与前面几个内核的最大的区别就在脚本处理上，Presto有着天生的优势，页面的全部或者部分都能够在回应脚本事件时等情况下被重新解析。
>  此外该内核在执行Javascrīpt的时候有着最快的速度，可惜Presto是商业引擎，使用Presto的除开Opera以外，只剩下NDSBrowser、Wii Internet Channle、Nokia 770网络浏览器等，这很大程度上限制了Presto的发展。Opera现已改用Google Chrome的Blink内核。
>
> 4. Webkit：
>
> Webkit(Safari内核,Chrome内核原型,开源)，它是苹果公司自己的内核，也是苹果的Safari浏览器使用的内核。 Webkit是自由软件，同时开放源代码。在安全方面不受IE、Firefox的制约，所以Safari浏览器在国内还是很安全的。
>  Google Chrome、360极速浏览器、搜狗高速浏览器高速模式使用Webkit作为内核。WebKit 内核在手机上的应用也十分广泛，例如 Google 的手机 Gphone、 Apple 的iPhone等所使用的 Browser 内核引擎，都是基于 WebKit。WebKit内核常见的浏览器：傲游浏览器3、Apple Safari(Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器。

----

### 4/22

#### 16. 常见浏览器所用内核

> | 常见浏览器| 所用内核 |
> | -------------- | -------- |
> | IE、360安全浏览器 | Trident  |
> | FireFox           | Gecko    |
> | Chrome、Safari    | Webkit   |

#### 17. 浏览器的渲染原理？

> 浏览器工作流程大体分为如下三部分：
>
> 1. 浏览器会解析三个东西：
>
> - 一个是HTML/SVG/XHTML，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。
> - CSS，解析CSS会产生CSS规则树。
> - Javascript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree.
>
> 2. 解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。
>
> - Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了。
> - CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element。也就是DOM结点。也就是所谓的Frame。
> - 然后，计算每个Frame（也就是每个Element）的位置，这又叫layout和reflow过程。
>
> 3. 最后通过调用操作系统Native GUI的API绘制。
>
> > *接下来我们针对这其中所经历的重要步骤，一一详细阐述。*
>
> ##### 构建DOM
>
> 浏览器会遵守一套步骤将HTML 文件转换为 DOM 树。宏观上，可以分为几个步骤：
>
>
>
> ![img](https://pic2.zhimg.com/80/v2-e66906563b9a196c00cb8811236bc941_1440w.png)
>
>
>
> - 浏览器从磁盘或网络读取HTML的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成字符串。
>
> 在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。
>
> - 将字符串转换成Token，例如：``、``等。**Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息**。
>
> 这时候你一定会有疑问，节点与节点之间的关系如何维护？
>
> 事实上，这就是Token要标识“起始标签”和“结束标签”等标识的作用。例如“title”Token的起始标签和结束标签之间的节点肯定是属于“head”的子节点。
>
>
>
> ![img](https://pic2.zhimg.com/80/v2-f0ae41af7647a86873f0299c9aea31d5_1440w.jpg)
>
>
>
> 上图给出了节点之间的关系，例如：“Hello”Token位于“title”开始标签与“title”结束标签之间，表明“Hello”Token是“title”Token的子节点。同理“title”Token是“head”Token的子节点。
>
> - 生成节点对象并构建DOM
>
> 事实上，构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。换句话说，每个Token被生成后，会立刻消耗这个Token创建出节点对象。**注意：带有结束标签标识的Token不会创建节点对象。**
>
> 接下来我们举个例子，假设有段HTML文本：
>
> ```html
> <html>
> <head>
>     <title>Web page parsing</title>
> </head>
> <body>
>     <div>
>         <h1>Web page parsing</h1>
>         <p>This is an example Web page.</p>
>     </div>
> </body>
> </html>
> ```
>
> 上面这段HTML会解析成这样：
>
>
>
> ![img](https://pic3.zhimg.com/80/v2-264b6ef49bdc36ebbd5180a4787af696_1440w.jpg)
>
>
>
> ##### 构建CSSOM
>
> DOM会捕获页面的内容，但浏览器还需要知道页面如何展示，所以需要构建CSSOM。
>
> 构建CSSOM的过程与构建DOM的过程非常相似，当浏览器接收到一段CSS，浏览器首先要做的是识别出Token，然后构建节点并生成CSSOM。
>
> 在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。
>
> **注意：CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去**。
>
> ##### 构建渲染树
>
> 当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。
>
>
>
> ![img](https://pic2.zhimg.com/80/v2-71eb942f1ed509feaebcaed851ae819d_1440w.jpg)
>
>
>
> 在这一过程中，不是简单的将两者合并就行了。**渲染树只会包括需要显示的节点和这些节点的样式信息**，如果某个节点是 `display: none`的，那么就不会在渲染树中显示。
>
> ##### 布局与绘制
>
> 当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
>
> 布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。
>
> 布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。

#### 18. 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）

> JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。
>
> 也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性（下文会介绍这两者的区别）。
>
> JS文件不只是阻塞DOM的构建，它会导致CSSOM也阻塞DOM的构建。
>
> 原本DOM和CSSOM的构建是互不影响，井水不犯河水，但是一旦引入了JavaScript，CSSOM也开始阻塞DOM的构建，只有CSSOM构建完毕后，DOM再恢复DOM构建。
>
> 这是什么情况？
>
> 这是因为JavaScript不只是可以改DOM，它还可以更改样式，也就是它可以更改CSSOM。前面我们介绍，不完整的CSSOM是无法使用的，但JavaScript中想访问CSSOM并更改它，那么在执行JavaScript时，必须要能拿到完整的CSSOM。所以就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和DOM构建，直至其完成CSSOM的下载和构建。也就是说，**在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后在继续构建DOM**。

#### 19. async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）

> ![img](https://pic4.zhimg.com/80/v2-909c198b7ef020ad8529cfa97f4ffd6f_1440w.jpg)
>
>
>
> 其中蓝色线代表JavaScript加载；红色线代表JavaScript执行；绿色线代表 HTML 解析。
>
> 1. 情况1
>
> 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。
>
> 2. 情况2 (**异步下载**)
>
> async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。
>
> 3. 情况3 (**延迟执行**)
>
> defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。
>
> defer 与相比普通 script，有两点区别：**载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。
>
> 在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载。
#### 20. 什么是文档的预解析？（浏览器解析过程）
> ##### 解析器与预解析机制
>
> 呈现引擎从网络层获取请求文档的内容，然后开始解析 HTML 文档，并将各标记逐个转化为 **DOM树（内容树）**上的 DOM 节点，同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：**渲染树（呈现树）**。呈现树构建完毕之后，呈现引擎将对呈现树进行布局和绘制。
>
> **呈现引擎** 的解析包括 HTML 解析和 CSS 解析，HTML 解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构，DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。解析树的根节点是“Document”对象。CSS 解析器会将 CSS 样式文件和样式元素中的样式数据解析为 CSS 规则树，浏览器结合 CSS 规则树和 DOM 树生成渲染树。
>
> **JavaScript 解释器** 用于解析和执行 JavaScript 代码。
>
> 一般来讲，我们认为浏览器从网络层接收到 HTML 文档内容，然后开始解析文档生成 DOM 树，遇到 CSS 样式表标签或 JS 脚本标签就起新线程去下载它们，并继续构建 DOM 树，浏览器根据 DOM 树构建渲染树，最后浏览器将渲染书绘制到用户界面。
>
> 在上述描述中，需要着重指出的是，HTML 文档的解析和渲染是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。
>
> 浏览器的预解析。WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析 HTML 文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。
>
> 浏览器的预解析可以减缓渲染被阻塞的情况，例如文档解析过程中预加载器发现了 \`\` 标签，会对 last.js 文件进行加载并放在浏览器缓存中，这样当解析器遇到这个 `<script>` 标记时，由于预加载器已经将 last.js 文件加载下来了，所以 last.js 会被立即执行，不需要等待从网络抓取资源，减缓了对渲染的阻塞。
----
### 4/23

#### HTML5 有哪些新特性、移除了那些元素？

> HTML5 现在已经不是SGML的子集，主要是关于图像，位置，存储，多任务等功能的增加。
>
> - 新特性：
>
>   - 绘画 `<canvas>`。
>
>     > 有关canvas的介绍请见：[浅谈HTML5 canvas（一）](http://blog.csdn.net/zhouziyu2011/article/details/65682406)和[浅谈HTML5 canvas（二）](http://blog.csdn.net/zhouziyu2011/article/details/66474969)
>
>   - 用于媒介回放的 `<video>` 和 `<audio>`。
>
>     > 有关video和audio的介绍请见：[浅谈HTML5中的和](http://blog.csdn.net/zhouziyu2011/article/details/69084961)
>
>   - Web Storage的本地存储 `<localStorage>` 和会话存储 `<sessionStorage>`。
>
>     > 有关localStorage和sessionStorage的介绍请见：[浅谈cookie、sessionStorage 和 localStorage](http://blog.csdn.net/zhouziyu2011/article/details/58591829)
>
>   - 语意化更好的内容元素，比如 `<article>` `<aside>` `<footer>` `<header>` `<nav>` `<section>` `<hgroup>`。
>
>   - 表单控件 `<calendar>` `<date>` `<time>` `<email>` `<url>` `<search>`。
>
>   - 新的技术 `<webworker>` `<websocket>` `<Geolocation>`。
>
>     > 有关websocket的介绍请见：[浅谈WebSocket](http://blog.csdn.net/zhouziyu2011/article/details/60871264)
>
> - 移除的元素：
>   - 纯表现的元素：`<basefont>` `<big>` `<center>` `<font>` `<s>` `<strike>` `<tt>` `<u>`。
>   - 对可用性产生负面影响的元素：`<frame>` `<frameset>` `<noframes>`

#### 如何处理 HTML5 新标签的浏览器兼容问题？

> 当在页面中使用HTML5新标签时，可能会得到三种不同的结果：
>
> - 结果1：新标签被当作错误处理并被忽略，在DOM构建时会当作这个标签不存在。
> - 结果2：新标签被当作错误处理，并在DOM构建时，这个新标签会被构造成行内元素。
> - 结果3：新标签被识别为HTML5标签，然后用DOM节点对其进行替换。
>
>
>
> 不能识别HTML5新标签而不能使用，解决办法有两种：
>
> - 方法1：实现标签被识别
>
>   > 通过document.createElement（tagName）方法即可让浏览器识别新标签，浏览器支持新标签后，还可以为新标签添加CSS样式。
>
> - 方法2：JavaScript解决方案
>
>   > - 使用html5shim：
>   >
>   >   > 在 `<head>` 中调用以下代码：
>   >   >
>   >   > ```javascript
>   >   > <!--[if lt IE 9]>
>   >   >
>   >   > 	<script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script>
>   >   >
>   >   > <![endif]-->
>   >   > ```
>   >   >
>   >   > 当然也可以直接把这个文件下载到自己的网站上，但这个文件必须在head标签中调用。
>   >
>   > - 使用kill IE6
>   >
>   >   > 在 `</body>` 之前调用以下代码：
>   >   > ```javascript
>   >   > <!--if lte IE 6]>
>   >   >   <script src="http://letskillie6.googlecode.com/svn/trunk/letskillie6.zh_CN.pack.js"></script>
>   >   > <![endif]-->
>   >   > ```
>
>
>
>
> 区分HTML和HTML5：
>
> - DOCTYPE声明
> - 新增的元素

#### 简述一下你对 HTML 语义化的理解？

> (1)HTML 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
> (2)即使在没有样式 CSS 的情况下也能以一种文档格式显示，并且是容易阅读的;
> (3)搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，有利于 SEO;
> (4)使阅读源代码的人更容易将网站分块，便于阅读、维护和理解。

#### iframe 有那些缺点？

> - 代码复杂，无法被一些搜索引擎索引到
> - iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。
> - 现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。

#### title 与 h1 的区别？

> h1突出文章主题，面对用户，更突出其视觉效果，突出网站标题或关键字用title。一篇文章，一个页面最好只用一个h1，多个h1会稀释主题。一个网站可以有多个title,最好一个单页用一个title，以便突出网站页面主体信息，从seo看，title权重比h1高，适用性比h1广。标记了h1的文字页面给予的权重会比页面内其他权重高很多。一个好的网站是h1和title并存，既突出h1文章主题，又突出网站主题和关键字。达到双重优化网站的效果。



----

### 4/24

#### 1. 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？

> <img src="/Users/apple/Documents/study/Coding/KKB/02 前端基础入门/box model.png" style="zoom: 50%;" />

#### 2. CSS选择符有哪些？

> - id 选择器（#myid）
> - 类选择器（.myclassname）
> - 标签选择器（div，h1，p）
> - 相邻选择器（h1 + p）
> - 子选择器（ul > li）
> - 后代选择器（li a）
> - 通配符选择器（* ）
> - 属性选择器（ a[rel = "external"]）
> - 伪类选择器（a: hover, li: nth - child）

#### 3. ::before 和 :after 中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。

> 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。无论使用单冒号还是双冒号，浏览器都将能识别它们。
>
> 伪元素将会在内容元素的前后插入额外的元素，但是这些元素实际上并不在文档中生成。
>
> `:before`将会在内容之前“添加”一个元素而`:after`将会在内容后“添加”一个元素。在它们之中添加内容我们可以使用content属性。

#### 4. 伪类与伪元素的区别

> - **伪类**用于选择DOM树之外的信息，或是不能用简单选择器进行表示的信息。前者包含那些匹配指定状态的元素，比如`:visited`，`:active`；后者包含那些满足一定逻辑条件的DOM树中的元素，比如`:first-child`，`:first-of-type`，`：target`。
> - **伪元素**为DOM树没有定义的虚拟元素。不同于其他选择器，它不以元素为最小选择单元，它选择的是元素指定内容。比如`::before`表示选择元素内容的之前内容，也就是`""`；`::selection`表示选择元素被选中的内容。

#### 5. CSS 中哪些属性可以继承？

> - **有继承性的属性**
>   - 字体系列属性
>   - 文本系列属性
>   - 元素可见性：visibility
>   - 表格布局属性
>   - 列表布局属性
>   - 生成内容属性：quotes
>   - 光标属性：cursor
>   - 页面样式属性：page、page-break-inside、windows、orphans
>   - 声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、、azimuth、elevation
>
>> - **所有元素可以继承的属性**
> >   - 元素可见性：visibility
> >   - 光标属性：cursor
>> - **内联元素可以继承的属性**
>>   - 字体系列属性
> >   - 除text-indent、text-align之外的文本系列属性
>> - **块级元素可以继承的属性**
> >   - text-indent、text-align
>

----

### 4/28

#### 11. position 的值 relative 和 absolute 定位原点是？

> relative：定位原点是元素本身所在位置；
> absolute：定位原点是离自己这一级元素最近的一级position设置为absolute或者relative的父元素的左上角

#### 12. CSS3 有哪些新特性？（根据项目回答）

> 1. CSS3实现圆角（border-radius），阴影（box-shadow），边框图片border-image
>
> 2. 对文字加特效（text-shadow），强制文本换行（word-wrap），线性渐变（linear-gradient）
> 3. 旋转,缩放,定位,倾斜：transform:rotate(90deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg)
> 4. 伪元素 ::selection ；
> 5. 媒体查询(@media)，flexbox
>

#### 13. 请解释一下 CSS3 的 Flexbox（弹性盒布局模型），以及适用场景？

> Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。
>
> 任何一个容器都可以指定为Flex布局。注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。
>
> 使用场景：垂直居中，处于中心，以及左中右三块布局

#### 14. 用纯 CSS 创建一个三角形的原理是什么？

> 元素的border是由**三角形**组合而成
>
> [参考](https://www.jianshu.com/p/9a463d50e441)

#### 15. 一个满屏品字布局如何设计?

> 上下 `flex-direction` 属性为 `column` 的div，设置 `align-items` 为 `center`；下面的div中再嵌套一个一个flexbox

----

### 五一练习题

#### 16. CSS 多列等高如何实现？

> 利用flex布局

#### 17. 经常遇到的浏览器的兼容性有哪些？原因、解决方法是什么，常用 hack的技巧？

> 1. 各浏览器不同标签margin,padding不同
>
>    > *{margin:0;padding:0;}
>
> 2. 居中问题，div里的内容，IE默认为居中，而Firefox默认为左对齐
>
>    > margin: 0 auto;
>
> 3. IE浮动 margin产生的双倍距离
>
>    ```css
>    #box {
>     float:left;
>         width:100px;
>         margin:0 0 0 100px; //这种情况之下IE会产生200px的距离
>         display:inline; //使浮动忽略
>    }
>    ```
>
> 4. ul标签在FF中默认是有 padding值的，而在IE中只有margin有值，还有缩进问题
>
>    ```css
>     {
>      list-style:none;
>     margin:0px;
>      padding:0px;
>    }
>    ```
>
>
>
> - **CSS Hack**是针对不同的浏览器书写不同的CSS样式，通过使用某个浏览器单独识别的样式代码，控制该浏览器的显示效果。
>
>   Hack 技巧：
>
>   - Firefox：
>
>     > 一般在所添加的样式前加-moz-
>     >
>     > 或者嵌套其专用的css语句：@-moz-document url-prefix()。
>     >
>     > ```css
>     > @-moz-document url-prefix() {
>     > .css-hack {
>     > color: blue; /* 只有FireFox显示为蓝色 */
>     > }}
>     > ```
> - Chrome、Safari等Webkit内核的浏览器
>
>   > 一般在所添加的样式前加-webkit-
>     >
>     > 支持媒体类型查询语句：
>     >
>     > ```css
>     > @media screen and (-webkit-min-device-pixel-ratio:0)。@media screen and (-webkit-min-device-pixel-ratio:0) {
>     > .css-hack {
>     > color: blue; /* Webkit内核浏览器显示蓝色 */
>     > }}
>     > ```
>   - IE
>
>     > 属性值后缀\9
>   >
>     > ```css
>     > .css-hack {
>     > background-color: red; /* 其他浏览器上显示为红色 */
>     > background-color: blue \9; /* 所有IE浏览器上显示为蓝色 */
>     > }
>     > ```
#### 18. li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？
> 有时候，我们需要将<li>横向排列，而又为了能设置其宽度和高度，为其设置 `display:inline-block` ，相邻<li>之间会出现8px的空白间隔，不是margin也不是padding。
>
> 原因：
>
> > 浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观，我们通常是一个<li>放在一行，这导致<li>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。
>
> 解决方法：
>
> > 消除<ul>的字符间隔 `letter-spacing: -8px`，而这也设置了<li>内的字符间隔，因此需要将<li>内的字符间隔设为默认 `letter-spacing: normal`。
#### 19. 为什么要初始化 CSS 样式？
> 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。
#### 20. 什么是包含块，对于包含块的理解？
> 包含块简单说就是定位参考框或者定位坐标参考系，元素一旦定义了**定位显示**（相对、绝对、固定）都具有包含块性质，它所包含的定位元素都将以该包含块为坐标系进行定位和调整。
>
> 包含块是视觉格式化模型的一个重要概念，它与框模型类似，也可以理解为一个矩形，而这个矩形的作用是为它里面包含的元素提供一个参考，元素的尺寸和位置的计算往往是由该元素所在的包含块决定的。
#### 21. CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？
> 当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 “hidden”。
>
> 对于一般的元素，它的表现跟 `display:hidden` 是一样的。但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟 `display: none` 一样，也就是说，它们占用的空间也会释放。
#### 22. width:auto 和 width:100% 的区别
> - `width: auto`：
>
>   > 是根据设定对象的实际大小而自适应宽度（考虑设定元素的margin值的大小）
>
> - `width: 100%`：
>
>   > 设定对象的宽度占父元素的100%（不论设定元素的margin值为多少）
#### 23. 绝对定位元素与非绝对定位元素的百分比计算的区别
> 绝对定位的宽高百分比计算是相对于padding box的，也就是说会把padding 大小值计算在内，但是，非绝对定位元素则是相对于content box计算的。
#### 24. 简单介绍使用图片 base64 编码的优点和缺点
> Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来标识二进制数据的方法。
> Base64是一种可逆的编码方式，是一种用64个Ascii字符来表示任意二进制数据的方法。
> 主要用于将不可打印字符转换为可打印字符，或者简单的说将二进制数据编码为Ascii字符。
>
> **优点**：
>
> > 可以将二进制数据转化为可打印字符，方便传输数据，对数据进行简单的加密，肉眼安全。
>
> **缺点**：
>
> > 内容编码后体积变大，编码和解码需要额外工作量。
#### 25. 'display'、'position' 和 'float' 的相互关系？
> - 如果一个元素的 `display` 属性被设置为 `none`，那么就不会生成元素对应的box，这种情况下，`float` 和 `position` 被忽略
>   - 否则（display非none），如果一个元素的 `position` 属性被设置为 `absolute` 或者 `fixed` （都是绝对定位），这种情况下，float被忽略（float计算的值为none），display属性的值根据下表自动计算。box的位置取决于属性top，right，bottom，left以及box的容器
>     - 否则（display非none，并且position非absolute、fixed），如果float的值不为null（为left或者right），那么box是浮动的并且display的值根据下表来计算
>       - 否则（display非none，并且position非absolute、fixed，float为none），如果元素是根元素，display的值根据下表来计算。（这种情况下有一个例外：在CSS2.1中定义，当display被指定的值是list-item时，计算结果的display的值为block或者list-item）
>         - 否则（display非none，并且position非absolute、fixed，float为none，不是根元素），那么就按照被指定的display的属性值来显示。
#### 26. margin 重叠问题的理解
> 在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。
>
> **折叠的结果：**
>
> >
> > 1. 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。
> > 2. 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。
> > 3. 两个外边距一正一负时，折叠结果是两者的相加的和。
>
> **产生折叠的必备条件：margin必须是邻接的!**
>
> 而根据w3c规范，两个margin是邻接的必须满足以下条件：
>
> > - 必须是处于常规文档流（非float和绝对定位）的[块级盒子](http://www.w3.org/TR/CSS2/visuren.html#block-boxes)，并且处于同一个[BFC](http://www.w3.org/TR/CSS2/visuren.html#block-formatting)当中。
> > - 没有线盒（inline盒子），没有空隙（[clearance](http://www.w3.org/TR/CSS2/visuren.html#clearance)，下面会讲到），没有padding和border将他们分隔开
> > - 都属于垂直方向上相邻的外边距，可以是下面任意一种情况
> >   - 元素的margin-top与其第一个常规文档流的子元素的margin-top
> >   - 元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top
> >   - height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom
> >   - 高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottom
>
> **解决方法——破坏产生折叠的条件即可：**
>
> > 1. 给元素添加浮动或者绝对定位（会影响整体布局，改动大）
> > 2. 将元素改为行内元素（会影响整体布局，改动大）
> > 3. 元素间插入一个高度大于0的div
> > 4. 使元素不在同一BFC中
#### 27. 对 BFC 规范（块级格式化上下文：block formatting context）的理解？
> 对一个元素设置css，首先需要知道这个元素是block还是inline类型。而BFC就是用来格式化块级盒子，同样管理inline类型的盒子还有IFC，以及其他的FC。那首先我们就来看看FC的概念。
>
> - **Formatting Context**：指页面中一个渲染区域，并且拥有一套渲染规则，他决定了其子元素如何定位，以及与其他元素的相互关系和作用。
>
> - BFC：块级格式化上下文，它是指一个独立的块级渲染区域，只有Block-level Box参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。
>
>   > - BFC的生成
>   >
>   >   > 既然上文提到BFC是一块渲染区域，那这块渲染区域到底在哪，它又是有多大，这些由生成BFC的元素决定，CSS2.1中规定满足下列CSS声明之一的元素便会生成BFC。
>   >   >
>   >   > - 根元素，即HTML元素
>   >   >
>   >   > - `float` 的值不为none；
>   >   >
>   >   > - `overflow` 的值不为visible；
>   >   >
>   >   > - `display` 的值为inline-block、table-cell、table-caption；
>   >   >
>   >   >   > p.s. 有人把display: table也认为可以生成BFC，其实这里的主要原因在于Table会默认生成一个匿名的table-cell，正是这个匿名的table-cell生成了BFC。
>   >   >
>   >   > - `position` 的值为absolute或fixed；
>   >
>   > - BFC的约束规则
>   >
>   >   > 浏览器对于BFC这块区域的约束规则如下：
>   >   >
>   >   > - 生成BFC元素的子元素会一个接一个的放置。垂直方向上他们的起点是一个包含块的顶部，俩个相邻子元素之间垂直距离取决于元素margin特性。在BFC中相邻的块级元素外边距会折叠。
>   >   > - 生成BFC元素的子元素中，每一个子元素的外边距和包含块的左边界相接触，（对于从右到左的格式化，右外边距和右边界相接触），除非这个子元素也创建了一个新的BFC（如它自身也是一个浮动元素）。
>   >
>   > - BFC的作用
>   >
>   >   > - 自适应两栏布局
>   >   > - 可以阻止元素被浮动元素覆盖
>   >   > - 如果元素里面包含浮动元素，可以清除内部浮动（原理：父元素创建了BFC后，里面的子元素即使是float也会参与高度计算）
>   >   > - 分属于不同BFC时，可以防止margin重叠
>
#### 28. IFC 是什么？
> `IFC(Inline Formatting Contexts) ` 直译为"内联格式化上下文"，IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响）
> IFC中的line box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。 同个ifc下的多个line box高度会不同。 IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。
> 那么IFC一般有什么用呢？
> 水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过 `text-align` 则可以使其水平居中。
> 垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其 `vertical-align:middle`，其他行内元素则可以在此父元素下垂直居中。
#### 29. 请解释一下为什么需要清除浮动？清除浮动的方式
> 对元素进行了浮动（float）后，该元素就会脱离文档流，浮动在文档之上。在CSS中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。
>
> float主要用于页面布局，然后在使用后没有清除浮动，就会后患无穷。
>
> **父级div定义 overflow:auto;**
>
> > 原理：使用overflow属性来清除浮动有一点需要注意，overflow属性共有三个属性值：hidden，auto，visible。我们可以使用hidden和auto值来清除浮动，但切记不能使用visible值，如果使用这个值，将无法达到清除浮动效果，其他两个值都可以。
> >
> > overflow 属性规定当内容溢出元素框时发生的事情。
#### 30. 使用 clear 属性清除浮动的原理？
> clear 属性是不让元素的周围有浮动元素。属性值可以为left、right、both、none、inherit。
>
> clear 属性只能作用在块级元素上。因此要设置 display：block。clear：both，则让清除两侧的浮动。
>
> 一般常写的时候还会加上后面两句：height：0；visibility：hidden；
>
> 这两句和content的值有关，如果content有值而你不想显示，则可以加上这两句，如果content为空，则不加也可以。
>
> 如果你需要显示content内容，则不可以加。
#### 31. zoom:1 的清除浮动原理?
> Zoom属性是IE浏览器的专有属性， 它可以设置或检索对象的缩放比例。
>
> 当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。
#### 32. 移动端的布局用过媒体查询吗？
> @media screen and (min-width: 400px) and (max-width: 700px) { … }
>
> @media handheld and (min-width: 20em), screen and (min-width: 20em) { … }
#### 33. 使用 CSS 预处理器吗？喜欢哪个？
> Scss
#### 34. CSS 优化、提高性能的方法有哪些？
> - 加载性能：
>
>   > 1. css压缩：将写好的css进行打包压缩，可以减少很多的体积；
>   > 2. css单一样式：当需要下边距和左边距的时候，很多时候选择：`margin: top 0 bottom 0`; 但 `margin-bottom: bottom;margin-left: left;` 执行的效率更高；
>   > 3. 减少使用 `@import`, 而建议使用 `link`, 因为后者在页面加载时一起加载，前者 是等待页面加载完成之后再进行加载;
>
> - 选择器性能：
>
>   > CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；
>   >
>   > - **避免使用通配规则**
>   >
>   >   如*{} 计算次数惊人！只对需要用到的元素进行选择
>   >
>   > - **尽量少的去对标签进行选择，而是用class**
>   >
>   >   如：#nav li{},可以为li加上nav_item的类名，如下选择.nav_item{}
>   >
>   > - **不要去用标签限定ID或者类选择符**
>   >
>   >   如：ul#nav,应该简化为#nav
>   >
>   > - **尽量少的去使用后代选择器，降低选择器的权重值**
>   >
>   >   后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素
>   >
>   > - **考虑继承**
>   >
>   >   了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则
> - 渲染性能：
>
>   > 1. 慎重使用高性能属性：浮动、定位；
>   > 2. 尽量减少页面重排、重绘；重排按照css的书写顺序：
>   >    - 位置：positon、top、left、z-index、float、dispay
>   >    - 大小：width、height、margin、padding
>   >    - 文字系列：font、line-height、color、letter-spacing
>   >    - 背景边框：background、 border
>   >    - 其它：anmation、transition
>   >    - 重绘：border、outline、background、box-shadow,能使用background-color,就尽量不要使用background;
>   > 3. 去除空规则：｛｝；
>   > 4. 属性值为0时，不加单位；
>   > 5. 属性值为浮动小数0.**，可以省略小数点之前的0；
>   > 6. 标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后；
>   > 7. 不使用@import前缀，它会影响css的加载速度；
>   > 8. 充分利用css继承属性，减少代码量；
>   > 9. 抽象提取公共样式，减少代码量；
>   > 10. 选择器优化嵌套，尽量避免层级过深；
>   > 11. css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用;
>   > 12. 将css文件放在页面最上面
> - 可维护性、健壮性：
>
>   > 1. 将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用,提高css的可维护性；
>   > 2. 继上一条，oocss也是提高css性能的途径之一，通过定义可复用的、语义化良好的基础类，然后添加到html中，这也是很多ui框架都在使用的一种方法，例如：class="btn btn-active btn-blue"；
>   > 3. 样式与内容分离：讲css代码定义到外部css中；
>   > 4. 容器与样式分离；
#### 35. 浏览器是怎样解析 CSS 选择器的？
> 按照从上到下，**从右到左**的顺序解析。
------
### 5/6
#### 36. 在网页中应该使用奇数还是偶数的字体？为什么呢？
>应该使用偶数字体
>
>1. 比例关系
>
>   相对来说偶数字号比较容易和页面中其他部分的字号构成一个比例关系。如我使用 14px 的字体作为正文字号，那么其他部分的字体（如标题）就可以使用 14×1.5 =21px 的字体，或者在一些地方使用到了 14×0.5=7px 的 padding 或者 margin，如果你是在用 sass 或者 less 编写 css，这时候用处就凸显出来了。
>
>2. UI 设计师的缘故
>
>   大多数设计师用的软件如 ps 提供的字号是偶数，自然到了  前端那边也是用的是偶数。
>
>3. 浏览器缘故
>   - 其一是低版本的浏览器 ie6 会把奇数字体强制转化为偶数，即 13px 渲染为 14px。
>   - 其二是为了平分字体。偶数宽的汉字，如 12px 的汉子，去掉 1 像素的字体间距，填充了的字体像素宽度其实就是 11px，这样的汉字中竖线左右是平分的，如“中”子，左右就是 5px 了。
>
>4. 系统差别
>
>   Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px 时用的是小一号的点阵（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。
>
>   而在 Linux 和其他手持设备上，奇数偶数的渲染效果其实相差不大。
#### 37. margin 和 padding 分别适合什么场景使用？
> - margin:
>
>   需要在border外侧添加空白时；
>
>    空白处不需要背景（色）时；
>
>   上下相连的两个盒子之间的空白，需要相互抵消时。
>
> - padding：
>
>   需要在border内测添加空白时；
>
>   空白处需要背景（色）时；
>
>   上下相连的两个盒子之间的空白，希望等于两者之和时。
#### 38. 抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]
> [参考](http://nec.netease.com/standard/css-sort.html)
> 通常，一个项目只引用一个CSS，但是对于较大的项目，需要把CSS文件进行分类。
>
> 按照CSS的性质和用途，将CSS文件分成“公共型样式”、“特殊型样式”、“皮肤型样式”，并以此顺序引用（按需求决定是否添加版本号）。
>
> 1. 公共型样式：包括了以下几个部分：“标签的重置和设置默认值”、“统一调用背景图和清除浮动或其他需统一处理的长样式”、“网站通用布局”、“通用模块和其扩展”、“元件和其扩展”、“功能类样式”、“皮肤类样式”。
> 2. 特殊型样式：当某个栏目或页面的样式与网站整体差异较大或者维护率较高时，可以独立引用一个样式：“特殊的布局、模块和元件及扩展”、“特殊的功能、颜色和背景”，也可以是某个大型控件或模块的独立样式。
> 3. 皮肤型样式：如果产品需要换肤功能，那么我们需要将颜色、背景等抽离出来放在这里。
#### 39. 简单说一下 css3 的 all 属性
> `all`属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction这两个CSS属性。
#### 40. 为什么不建议使用通配符初始化 css 样式
> 主要是性能问题。如果用通配符重置样式，那么势必会花费很大时间。网站打开速度变慢。
------
### 5/7
#### 41. absolute 的 containing block （包含块）计算方式跟正常流有什么不同？
> 若此元素为inline元素，则container block为能够包含这个元素生成的第一个和最后一个inline box的padding box（除margin，border外的区域）的最小矩形
> *否则，则由这个祖先元素的padding box组成
> 如果都找不到，则为initial containing block;
>
> 补充：
> *static（默认的)/relative：简单来说就是它的父元素的内容框（即去掉padding的部分）
> *absolute：向上找最近的定位为absolute/relative的元素
> *fixed：它的containing block一律为根元素（html/body)，根元素也是initial containing block
#### 42. 对于 hasLayout 的理解？
> Layout 是 IE 浏览器渲染引擎的一个内部组成部分。在 IE 浏览器中，一个元素要么自己对自身的内容进行组织和计算大小， 要么依赖于包含块来计算尺寸和组织内容。为了协调这两种方式的矛盾，渲染引擎采用了 ‘hasLayout’ 属性，属性值可以为 true 或 false。 当一个元素的 `hasLayout` 属性值为 true 时，我们说这个元素有一个布局（layout），或拥有布局。可以通过 hasLayout 属性来判断一个元素是否拥有 layout ，如 `object.currentStyle.hasLayout` 。
>
> hasLayout 与 BFC 有很多相似之处，但 hasLayout 的概念会更容易理解。在 Internet Explorer 中，元素使用“布局”概念来控制尺寸和定位，分为拥有布局和没有布局两种情况，拥有布局的元素由它控制本身及其子元素的尺寸和定位，而没有布局的元素则通过父元素（最近的拥有布局的祖先元素）来控制尺寸和定位，而一个元素是否拥有布局则由 hasLayout 属性告知浏览器，它是个布尔型变量，true 代表元素拥有布局，false 代表元素没有布局。简而言之，hasLayout 只是一个 IE 下专有的属性，hasLayout 为 true 的元素浏览器会赋予它一系列的效果。
>
> **特别注意的是，hasLayout 在 IE 8 及之后的 IE 版本中已经被抛弃，所以在实际开发中只需针对 IE 8 以下的浏览器为某些元素触发 hasLayout。**
#### 43. 元素竖向的百分比设定是相对于容器的高度吗？
> 元素竖向的百分比设定是相对于容器的宽度，而不是高度
#### 44. 全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）
> 原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现
>
> 用到的CSS属性：overflow：hidden；transition：all 1000ms ease；
#### 45. 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）
> 响应式网站设计(Responsive Web design)的理念是：集中创建页面的图片排版大小，可以智能地根据用户行为以及 使用的设备环境（系统平台、屏幕尺寸、屏幕定向等）进行相对应的布局，无论用户正在使用笔记本还是iPad，我们 的页面都应该能够自动切换分辨率、图片尺寸及相关脚本功能等，以适应不同设备。
>
> 响应式网页设计就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。
>
> 响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有meta声明viewport：
>```html
> <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”>
>```
> 兼容IE可以使用JS辅助一下来解决
------
### 5/11
#### 47.如何修改 chrome 记住密码后自动填充表单的黄色背景？
> chrome表单自动填充后，input文本框的背景会变成黄色的，通过审查元素可以看到这是由于chrome会默认给自动填充的input表单加上 `input:-webkit-autofill` 私有属性，然后对其赋予以下样式：
>
>```css
> {
> background-color:rgb(250,255,189)!important;
> background-image:none!important;
> color:rgb(0,0,0)!important;
> }
> ```
>
>对chrome默认定义的background-color，background-image，color使用important是不能提高其优先级的，但是其他属性可使用。
>
> 使用足够大的纯色内阴影来覆盖input输入框的黄色背景，处理如下：
>
> ```css
>input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill{
> -webkit-box-shadow:000px1000pxwhiteinset;
> border:1pxsolid#CCC!important;
> }
> ```
#### 48.怎么让 Chrome 支持小于 12px 的文字？
> 在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。
>
> 解决办法：
>
> （1）可以使用Webkit的内核的 `-webkit-text-size-adjust` 的私有CSS属性来解决，只要加了 `-webkit-text-size-adjust:none;` 字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持 `-webkit-text-size-adjust` 样式，所以要使用时候慎用。
>
> （2）还可以使用css3的 `transform` 缩放属性 `-webkit-transform:scale(0.5);` 注意 `-webkit-transform:scale(0.75);` 收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用 `display：block/inline-block/...；`
>
> （3）使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。
#### 49.让页面里的字体变清晰，变细用 CSS 怎么做？
> webkit内核的私有属性：`-webkit-font-smoothing`，用于字体抗锯齿，使用后字体看起来会更清晰舒服。
>
> 在MacOS测试环境下面设置 `-webkit-font-smoothing:antialiased;` 但是这个属性仅仅是面向MacOS，其他操作系统设置后无效。
#### 50.font-style 属性中 italic 和 oblique 的区别？
> `italic` 和 `oblique` 这两个关键字都表示“斜体”的意思。
>
> 它们的区别在于，`italic` 是使用当前字体的斜体字体，而 `oblique` 只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，
> 则退而求其次，解析为`oblique`，也就是单纯形状倾斜。
#### 51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？
> 设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。
>
> css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，它是相对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。
>
> dpr指的是设备像素和设备独立像素的比值，一般的pc屏幕，dpr=1。在iphone4时，苹果推出了retina屏幕，它的dpr为2。屏幕的缩放会改变dpr的值。
>
> ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。
------
### 5/12
#### 52. layout viewport 、visual viewport 和 ideal viewport 的区别？
> 移动端一共需要理解三个viewport的概念的理解。
>
> 第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整个页面的布局都会显示错乱。所以移动端浏览器提供了一个 `layoutviewport` 布局视口的概念，使用这个视口来对页面进行布局展示，一般layoutviewport的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。
>
> 第二个视口指的是视觉视口，`visualviewport` 指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。visualviewport和layoutviewport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口中的网页内容。
>
> 第三个视口是理想视口，由于layoutviewport一般比visualviewport要大，所以想要看到整个页面必须通过拖动和缩放才能实现。所以又提出了 `idealviewport` 的概念，idealviewport下用户不用缩放和滚动条就能够查看到整个页面，并且页面在不同分辨率下显示的内容大小相同。idealviewport其实就是通过修改layoutviewport的大小，让它等于设备的宽度，这个宽度可以理解为是设备独立像素，因此根据idealviewport设计的页面，在不同分辨率的屏幕下，显示应该相同。
#### 55. 如何去除 inline-block 元素间间距？
> 使用margin负值、使用font-size:0、letter-spacing、word-spacing
#### 56. overflow: scroll 时不能平滑滚动的问题怎么处理？
> 以下代码可解决这种卡顿的问题：`-webkit-overflow-scrolling:touch;` 是因为这行代码启用了硬件加速特性，所以滑动很流畅。
#### 57. 有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。
> 使用flex布局，设置主轴为竖轴，第二个div的 `flex-grow` 为1。
#### 58. png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？
> （1）BMP，是无损的、既支持索引色也支持直接色的、点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常具有较大的文件大小。
>
> （2）GIF是无损的、采用索引色的、点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但，GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。
>
> （3）JPEG是有损的、采用直接色的、点阵图。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。
>
> （4）PNG-8是无损的、使用索引色的、点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。现在，除非需要动画的支持，否则我们没有理由使用GIF而不是PNG-8。
>
> （5）PNG-24是无损的、使用直接色的、点阵图。PNG-24的优点在于，它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。
>
> （6）SVG是无损的、矢量图。SVG是矢量图。这意味着SVG图片由直线和曲线以及绘制它们的方法组成。当你放大一个SVG图片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制企业Logo、Icon等。
>
> （7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的、点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。
>
> - 在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；
> - 在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；
> - WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。但是目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。
------
### 5/13
#### 61. style 标签写在 body 后与 body 前有什么区别？
> 页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题）
#### 62. 什么是 CSS 预处理器 / 后处理器？
> CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件。
>
> 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或lesscsssprite，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作率。
>
> CSS后处理器是对CSS进行处理，并最终生成CSS的预处理器，它属于广义上的CSS预处理器。我们很久以前就在用CSS后处理器了，最典型的例子是CSS压缩工具（如clean-css），只不过以前没单独拿出来说过。还有最近比较火的Autoprefixer，以CanIUse上的浏览器支持数据为基础，自动处理兼容性问题。
>
> 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。
#### 64. 使用 rem 布局的优缺点？
> 优点：
> 在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好。
>
> 缺点：
> （1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。
> （2）使用iframe引用也会出现问题。
> （3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。
#### 65. 几种常见的 CSS 布局
> [几种常见的 CSS 布局](https://juejin.im/post/5bbcd7ff5188255c80668028#heading-12)
> ![img](https://user-gold-cdn.xitu.io/2018/12/21/167cf5f402950001?imageslim)
#### 67. transition 和 animation 的区别
> `transition` 关注的是CSSproperty的变化，property值和时间的关系是一个三次贝塞尔曲线。
>
> `animation` 作用于元素本身而不是样式属性，可以使用**关键帧**的概念，应该说可以实现更自由的动画效果。
------
### 5/14
#### 68. 什么是首选最小宽度？
> “首选最小宽度”，指的是元素最适合的最小宽度。
>
> 东亚文字（如中文）最小宽度为每个汉字的宽度。
>
> 西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短横线、问号以及其他非英文字符等。
>
> 如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的`word-break:break-all`。
#### 69. 为什么 height:100% 会无效？
> 对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。
>
> 原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，所以无法参与计算。
>
> 使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。
#### 70. min-width/max-width 和 min-height/max-height 属性间的覆盖规则？
> 1. `max-width` 会覆盖width，即使width是行类样式或者设置了!important。
> 2. `min-width` 会覆盖max-width，此规则发生在min-width和max-width冲突的时候。
#### 71. 内联盒模型基本概念
> 1. 内容区域（contentarea）。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子（characterbox）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些元素，内容区域可以看成元素自身。
> 2. 内联盒子（inlinebox）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。
> 3. 行框盒子（linebox），每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。
> 4. 包含块（containingbox），由一行一行的“行框盒子”组成。
#### 72. 什么是幽灵空白节点？
> “幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但又确确实实地存在，表现如同文本节点一样，因此，称之为“幽灵空白节点”。
------
### 5/15
#### 73.什么是替换元素？
>通过修改某个属性值呈现的内容就可以被替换的元素就称为**替换元素**。因此，`<img>`、`<object>`、`<video>`、`<iframe>`或者表单元素`<textarea>`和`<input>`和`<select>`都是典型的替换元素。
>
>替换元素除了内容可替换这一特性以外，还有以下一些特性。
>
>（1）内容的外观不受页面上的CSS的影响。用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者**浏览器自身暴露的一些样式接口**
>
>（2）有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如`<video>`、`<iframe>`或者`<canvas>`等，也有少部分替换元素为0像素，如<img>图片，而表单元素的替换元素的尺寸则和浏览器有关，没有明显的规律。
>
>（3）在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是 `vertical-align` 属性，对于替换元素和非替换元素，`vertical-align` 属性值的解释是不一样的。比方说`vertical-align` 的默认值的`baseline`，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。
>
>（4）所有的替换元素都是 `内联水平元素`，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的 `display` 值却是不一样的，有的是 `inline`，有的是 `inline-block`。
#### 74.替换元素的计算规则？
> 替换元素的尺寸从内而外分为3类：**固有尺寸**、**HTML尺寸**和**CSS尺寸**。
>
> （1）**固有尺寸**指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。
>
> （2）**HTML尺寸**只能通过HTML原生属性改变，这些HTML原生属性包括<img>的width和height属性、<input>的size属性、<textarea>的cols和rows属性等。
>
> （3）**CSS尺寸**特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的contentbox。
>
> 这3层结构的计算规则具体如下
>
> 1. 如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。
> 2. 如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。
> 3. 如果有CSS尺寸，则最终尺寸由CSS属性决定。
> 4. 如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。
> 5. 如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。
> 6. 内联替换元素和块级替换元素使用上面同一套尺寸计算规则。
#### 75.content 与替换元素的关系？
> `content` 属性生成的对象称为“匿名替换元素”。
>
> （1）**我们使用content生成的文本是无法选中、无法复制的**，好像设置了`userselect: none` 声明一般，但是普通元素的文本却可以被轻松选中。同时，content生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是地把重要的文本信息使用content属性生成，因为这对可访问性和SEO都很不友好。
>
> （2）content生成的内容不能左右: empty伪类。
>
> （3）content动态生成值无法获取。
------
### 5/18
#### 76. margin:auto 的填充规则？
> margin的 `auto` 用来计算元素对应方向应该获得的剩余间距大小。触发 `margin:auto` 计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。
>
> （1）如果一侧定值，一侧auto，则auto为剩余空间大小；
> （2）如果两侧均是auto，则平分剩余空间.
#### 77. margin 无效的情形
> 1. `display` 计算值 `inline` 的非替换元素的垂直margin是无效的。对于内联替换元素，垂直margin有效，并且没有margin合并的问题。
> 2. 表格中的<tr>和<td>元素或者设置display计算值是 `table-cell` 或 `table-row` 的元素的margin都是无效的。
> 3. 绝对定位元素非定位方位的margin值“无效”。
> 4. 定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。
#### 78. border 的特殊性？
> 1. `border-width` 不支持百分比。
> 2. `border-style` 的默认值是 `none`，有一部分人可能会误以为是solid。这也是单纯设置border-width或border-color没有边框显示的原因。
> 3. `border-style: double` 的表现规则：双线宽度永远相等，中间间隔±1。
> 4. `border-color` 默认颜色就是color色值。
> 5. 默认background背景图片是相对于padding box定位的。
------
### 5/20
#### 79.什么是基线和 x-height？
> 字母x的下边缘（线）就是我们的基线。
>
> **x-height**指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在CSS世界中，middle指的是基线往上1/2x-height高度。我们可以近似理解为字母x交叉点那个位置。
#### 80.line-height 的特殊性？
> （1）对于**非替换元素**的纯内联元素，其可视高度完全由 `line-height` 决定。对于文本这样的纯内联元素，`line-height` 就是高度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。
>
> （2）内联元素的高度由**固定高度**和**不固定高度**组成，这个不固定的部分就是这里的“行距”。换句话说，`line-height` 之所以起作用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。
>
> （3）行距 = line-height-font-size。
>
> （4）`border` 以及 `line-height` 等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下边距，则向上取整。
>
> （5）对于纯文本元素，`line-height` 直接决定了最终的高度。但是，如果同时有替换元素，则 `line-height` 只能决定最小高度。
>
> （6）对于块级元素，`line-height` 对其本身是没有任何作用的，我们平时改变 `line-height`，块级元素的高度跟着变化实际上是通过改变块级元素里面内联级别元素占据的高度实现的。
>
> （7）`line-height` 的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前 `font-size` 相乘后的值。为百分比值时，其最终的计算值是和当前 `font-size` 相乘后的值。为长度值时原意不变。
>
> （8）如果使用数值作为 `line-height` 的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值。
>
> （9）无论内联元素 `line-height` 如何设置，最终父级元素的高度都是由数值大的那个 `line-height` 决定的。
>
> （10）只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。
#### 81.vertical-align 的特殊性？
> （1）`vertical-align` 的默认值是baseline，即**基线对齐**，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字母x的下边缘对齐的。对于图片等**替换元素**，往往使用元素本身的下边缘作为基线。一个 `inline-block` 元素，如果里面没有内联元素，或者 `overflow` 不是 `visible`，则该元素的基线就是其 `margin` 底边缘；否则其基线就是元素里面最后一行内联元素的基线。
>
> （2）`vertical-align: top` 就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果 `display` 计算值是 `table-cell` 的元素，我们不妨脑补成 `<td>` 元素，则和`<tr>` 元素上边缘对齐。
>
> （3）`vertical-align: middle` 是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上1/2x-height处对齐。对于 `table-cell` 元素，单元格填充盒子相对于外面的表格行居中对齐。
>
> （4）`vertical-align` 支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上偏移。
>
> （5）`vertical-align` 属性的百分比值则是相对于 `line-height` 的计算值计算的。
>
> （6）`vertical-align` 起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及`display` 值为 `table-cell` 的元素。
>
> （7）`table-cell` 元素设置 `vertical-align` 垂直对齐的是子元素，但是其作用的并不是子元素，而是 `table-cell` 元素自身。
------

### 5/21
#### 82. overflow 的特殊性？
> 一个设置了 `overflow: hidden` 声明的元素，假设同时存在border属性和padding属性，则当子元素内容超出容器宽度高度限制的时候，剪裁的边界是border box的内边缘，而非padding box的内边缘。
#### 83. 无依赖绝对定位是什么？
> **`absolute` 是非常独立的CSS属性值，其样式和属性不依赖其他任何CSS属性就可以完成。**
>
> > **Q**：一个绝对定位元素，没有任何 `left` / `top` / `right` / `bottom` 属性设置，并且其祖先元素全部都是非定位元素，其位置在哪里？
> >
> > > **A**：==> 还是在当前位置！
>
> 没有设置 `left` / `top` / `right` / `bottom` 属性值的绝对定位称为“无依赖绝对定位”。
#### 84. absolute 与 overflow 的关系？
> 绝对定位元素不总是被父级 `overflow` 属性剪裁，尤其当 `overflow` 在绝对定位元素及其包含块之间的时候。
>
> > 如果 `overflow` 不是定位元素，同时绝对定位元素和 `overflow` 容器之间也没有定位元素，则 `overflow` 无法对 `absolute` 元素进行剪裁。

------

### 5/22

#### 85. clip 裁剪是什么？

> 指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。
>
> `clip` 属性要想起作用，元素必须是绝对定位或者固定定位，也就是 `position` 属性值必须是 `absolute` 或者 `fixed`。
>
> 语法：`clip: rect(top right bottom left)`

#### 86. relative 的特殊性？

> 1. 相对于自身进行偏移定位
> 2. 当 `relative` 进行定位偏移的时候，一般情况下不会影响周围元素的布局

#### 87. 什么是层叠上下文？

> 层叠上下文，英文称作stackingcontext，是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就"高人一等"。